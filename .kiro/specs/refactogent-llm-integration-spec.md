# RefactoGent LLM Integration Spec

## Purpose
The LLM is the **refactor engine** within RefactoGent. It should never operate in isolation but instead consume the structured pre-work generated by the system. This ensures that refactors are safe, style-consistent, and aligned with project rules.

---

## Refactor Context Package (RCP)
Before any LLM call, RefactoGent compiles an RCP containing:

- **Code Selection**
  - Target file(s), functions, or modules.
  - Local AST + dependency graph for affected code.

- **Project Guardrails**
  - `.refactor-agent.yaml` (rules, styles, banned changes).
  - Framework / runtime versions.

- **Testing Signals**
  - Existing test files and coverage data.
  - Identified coverage gaps.

- **Repo Context**
  - Extracted naming conventions and linting rules.
  - Recognized architectural patterns (ORM, DI, middleware, etc.).

---

## LLM Task Types

1. **Refactor Proposal**
   - Input: RCP
   - Output: PR-ready patch diff.
   - Must cite followed guardrails.

2. **Test Creation / Augmentation**
   - Input: RCP + coverage map
   - Output: New or modified test files matching project style.

3. **Validation & Self-Critique**
   - Input: Diff + guardrails
   - Output: Flags violations or inconsistencies before commit.

---

## Execution Flow

1. Task runner prepares RCP.
2. Call LLM with system prompt encoding guardrails + repo signals.
3. Normalize output into patch + metadata.
4. Run validators (static checks, tests).
5. (Optional) LLM self-critique pass.
6. Deliver result as PR or IDE patch.

---

## Principles

- **Deterministic first, generative second**: deterministic pre-work always shapes LLM output.
- **Multiple passes**: different LLM calls may be used for refactor, test gen, and critique.
- **Never direct-to-repo**: every LLM output must pass RefactoGent validators before being offered for commit.
- **Extensible**: new task types (e.g. doc generation, migration helpers) can be layered in without breaking flow.
